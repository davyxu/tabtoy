package printer

import (
	"bytes"
	"go/parser"
	"go/printer"
	"go/token"
	"text/template"

	"github.com/davyxu/tabtoy/exportorv2/model"
)

const goTemplate = `// Generated by github.com/davyxu/tabtoy
// Version: {{.ToolVersion}}
// DO NOT EDIT!!
package table

import(
	"gamedef"
	{{if .HasAnyIndex}}"fmt"{{end}}
)

{{range $a, $row := .Rows}} {{range .Indexes}}
var {{$row.Name}}By{{.Name}} = make(map[{{.KeyType}}]*gamedef.ItemDefine)
{{end}} {{end}}
func Make{{.Name}}Index(v *{{.Package}}.{{.Name}}) {
	{{range $a, $row := .Rows}}
	// {{$row.Name}}
	for _, def := range v.{{$row.Name}} {
		{{range .Indexes}}
		if _, ok := {{$row.Name}}By{{.Name}}[def.{{.Name}}]; ok {
			panic(fmt.Sprintf("duplicate index in {{$row.Name}}By{{.Name}}: %v", def.{{.Name}}))
		}
		{{end}}		
		{{range .Indexes}}
		{{$row.Name}}By{{.Name}}[def.{{.Name}}] = def{{end}}
	}
	{{end}}
}

`

type goIndexModel struct {
	*model.FieldDescriptor
}

func (self *goIndexModel) KeyType() string {
	return model.FieldTypeToString(self.Type)
}

type goRowModel struct {
	*model.FieldDescriptor

	Indexes []*goIndexModel
}

type goFileModel struct {
	*model.FileDescriptor
	ToolVersion string
	Rows        []*goRowModel
	IndexCount  int
}

func (self *goFileModel) HasAnyIndex() bool {
	return self.IndexCount > 0
}

func (self *goFileModel) Package() string {
	return self.FileDescriptor.Pragma.Package
}

type goPrinter struct {
}

func (self *goPrinter) Run(g *Globals) *BinaryFile {

	tpl, err := template.New("golang").Parse(goTemplate)
	if err != nil {
		log.Errorln(err)
		return nil
	}

	var fm goFileModel
	fm.ToolVersion = g.Version
	fm.FileDescriptor = g.FileDescriptor

	// 遍历字段
	for _, fd := range g.CombineStruct.Fields {

		// 对CombineStruct的XXDefine对应的字段
		if g.CombineStruct.Usage == model.DescriptorUsage_CombineStruct {

			// 这个字段被限制输出
			if fd.Complex != nil && !fd.Complex.File.MatchTag(".go") {
				continue
			}

			// 这个结构有索引才创建
			if fd.Complex != nil && len(fd.Complex.Indexes) > 0 {

				rm := goRowModel{FieldDescriptor: fd}

				// 索引字段
				for _, key := range fd.Complex.Indexes {

					rm.Indexes = append(rm.Indexes, &goIndexModel{
						FieldDescriptor: key,
					})
					fm.IndexCount++
				}

				fm.Rows = append(fm.Rows, &rm)

			}

		}
	}

	bf := NewBinaryFile()

	err = tpl.Execute(bf.Buffer(), &fm)
	if err != nil {
		log.Errorln(err)
		return nil
	}

	if err := formatCode(bf.Buffer()); err != nil {
		log.Errorln("format golang code err", err)
		return nil
	}

	return bf
}

func formatCode(bf *bytes.Buffer) error {

	fset := token.NewFileSet()

	ast, err := parser.ParseFile(fset, "", bf, parser.ParseComments)
	if err != nil {
		return err
	}

	bf.Reset()

	err = (&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(bf, fset, ast)
	if err != nil {
		return err
	}

	return nil
}

func init() {

	RegisterPrinter(".go", &goPrinter{})

}
